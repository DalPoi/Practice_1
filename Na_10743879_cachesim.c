
// Filename: Na_10743879_cachesim.c
// Author: Seungwoo Na
// Student ID: 10743879
// Creation Date: 10 March 2025
// Modification Date: 27 March 2025

// This program simulates a direct-mapped cache system.
// It takes a memory trace file and cache configuration.
// It takes command-line arguments and prints cache performance metrics.

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>

// Structure representing a single cache line
// Contains tag, valid bit, and dirty bit
typedef struct {
    uint32_t tag; 
    int valid;    
    int dirty;    
} CacheBlock;

// Simulation parameters
int WIB; // Words in block
int BIC; // Blocks in cache
CacheBlock* cache_array; // Cache array

// Simulation result variables
int CPUR = 0, CPUW = 0; // CPU reads/writes accesses
int NRA = 0, NWA = 0;   // External memory reads/writes accesses
int NCRH = 0, NCRM = 0; // Cache read hits/misses
int NCWH = 0, NCWM = 0; // Cache write hits/misses


// Splits a 32-bit memory address into tag, index, and offset based on cache configuration

// Generated by ChatGPT in response to the prompt:
// "Write a C function that decodes a memory address into tag, index, and offset based on the cache configuration."
void decode_address(uint32_t address, uint32_t* tag, uint32_t* index, uint32_t* offset) {
    int offset_bits = 0, temp = WIB;
    while (temp >>= 1) offset_bits++;

    int index_bits = 0;
    temp = BIC;
    while (temp >>= 1) index_bits++;

    *offset = address & ((1 << offset_bits) - 1);
    *index = (address >> offset_bits) & ((1 << index_bits) - 1);
    *tag = address >> (offset_bits + index_bits);
}

// Simulates a single read or write operation at a given address

// Generated by ChatGPT in response to the prompt:
// "Write a C function that simulates a read or write operation at a given address in a direct-mapped cache."
// Then modified by the author.
void simulation_access(char operation, uint32_t address) {
    uint32_t tag, index, offset;
    decode_address(address, &tag, &index, &offset);
    CacheBlock* line = &cache_array[index];

    // Update CPU read and write request
    if (operation == 'R') CPUR++;
    else if (operation == 'W') CPUW++;

    // Check cache hit or miss
    if (line->valid && line->tag == tag) {
        // Cache hit operation
        if (operation == 'R') {
            NCRH++;
        } else if (operation == 'W') {
            NCWH++;
            line->dirty = 1;
        }
    } else {
        // Cache miss operation
        if (line->valid && line->dirty) {
            NWA++; 
        }
        if (operation == 'R') {
            NCRM++;
        } else if (operation == 'W') {
            NCWM++;
        }
        NRA++;
        
        // Update cache block
        line->tag = tag;
        line->valid = 1;
        line->dirty = (operation == 'W');
    }
}

// Check for correct command line arguments (4 arguments)
int main(int argc, char* argv[]) {
    if (argc != 4) {
        fprintf(stderr, "Correct Use: %s filename WIB BIC\n", argv[0]);
        return 1;
    }

    // Extract filename from arguments
    char* filename = argv[1];

    // Convert WIB and BIC to integer

    // Generated by ChatGPT in response to the prompt:
    // "Write C code to extract the WIB and BIC integers from the command line arguments."
    // Then modified by the author.
    char* wib_endptr;
    char* bic_endptr;
    WIB = (int)strtol(argv[2], &wib_endptr, 10);
    BIC = (int)strtol(argv[3], &bic_endptr, 10);

    // Check whether WIB or BIC contain invalid characters
    if (*wib_endptr != '\0' || *bic_endptr != '\0') return 1;

    // Allocate cache
    cache_array = calloc(BIC, sizeof(CacheBlock));
    if (!cache_array) return 1;

    // Open trace file
    FILE* trace_file = fopen(filename, "r");
    if (!trace_file) return 1;

    // Read and process each line in the trace file
    char line[32];
    char access_type;
    uint32_t address, dummy;

    while (fgets(line, sizeof(line), trace_file)) {
        if (line[0] == '!' || line[0] == '\n' || line[0] == '\0') continue; // Ignore comments or empty lines

        if (sscanf(line, " %c %x %x", &access_type, &address, &dummy) == 3) {
            simulation_access(access_type, address);
        }
    }

    fclose(trace_file);

    // Simulator output in required format
    printf("%d %d %d %d %d %d %d %d %d %d %s\n",
           CPUR, CPUW, 
           NRA, NWA,
           NCRH, NCRM,
           NCWH, NCWM,
           WIB, BIC, filename);

    // Avoid memory leaks
    free(cache_array);
    return 0;
}
